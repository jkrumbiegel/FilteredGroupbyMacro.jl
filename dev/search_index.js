var documenterSearchIndex = {"docs":
[{"location":"#GroupbyIndexingMacro.jl-1","page":"Home","title":"GroupbyIndexingMacro.jl","text":"","category":"section"},{"location":"#Filtered-split-apply-combine-as-in-R's-data.table-1","page":"Home","title":"Filtered split-apply-combine as in R's data.table","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"GroupbyIndexingMacro.jl offers a macro @by with which a concise syntax for filtered split-apply-combine operations can be expressed concisely. It is very similar in nature to the [i,j,by] indexing that the well-known package data.table in the R ecosystem uses.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The order is slightly different. Here, you have to specify:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[filter, grouping_keys, new_column_keyword_args...]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"An example with the well-known diamonds dataset:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using RDatasets\nusing GroupbyIndexingMacro\nusing StatsBase\n\ndiamonds = dataset(\"ggplot2\", \"diamonds\")\n\n# filter by Price and Carat\n# then group by Cut\n# finally compute new columns with keyword names\n@by diamonds[(:Price .> 3000) .& (:Carat .> 0.3), :Cut,\n    MeanPricePerCarat = mean(:Price) / mean(:Carat),\n    MostFreqColor = sort(collect(countmap(:Color)), by = last)[end][1]]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Internally, the macro transforms the indexing syntax to the functional equivalent of the following standard DataFrames function calls:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using RDatasets # hide\nusing GroupbyIndexingMacro # hide\nusing StatsBase # hide\n\ndiamonds = dataset(\"ggplot2\", \"diamonds\") # hide\n\nby(diamonds[(diamonds.Price .> 3000) .& (diamonds.Carat .> 0.3), :], :Cut,\n    MeanPricePerCarat = (:Price, :Carat) => x -> mean(x.Price) / mean(x.Carat),\n    MostFreqColor = :Color => x -> sort(collect(countmap(x)), by = last)[end][1])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As you can see there are a couple of redundancies in the default syntax. Especially for computations using multiple columns, the standard new_column = columns => function syntax is much more verbose and less readable.","category":"page"},{"location":"#Assignment-syntax-1","page":"Home","title":"Assignment syntax","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can also use assignment syntax with the := operator. This is not a mutating operation as in R's data.table but returns a new DataFrame, in which the result of the split-apply-combine operation is joined with the original data. This is handy if you want to keep working with a full dataset after calculating group-wise summary statistics which are then repeated for each group row.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using GroupbyIndexingMacro # hide\nusing DataFrames # hide\ndf = DataFrame(a = repeat(1:3, 3), b = repeat('a':'c', 3))\n@by df[!, :b, sum_a := sum(:a)]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compare this to the non-assignment syntax:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using GroupbyIndexingMacro # hide\nusing DataFrames # hide\ndf = DataFrame(a = repeat(1:3, 3), b = repeat('a':'c', 3)) # hide\n@by df[!, :b, sum_a = sum(:a)]","category":"page"}]
}
